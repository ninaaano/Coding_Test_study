package study001;

import java.util.Scanner;

public class p1929 {
	
	// 소수 구하기
	// M이상 N이하의 소수를 모두 출력하는 프로그램 작성
	// 1번째 줄에 자연수 M과 N이 빈칸을 사이에 두고 주어진다
	// (1<=M<=N<=1,000,000). M이상 N이하의 소수가 1개 이상 있는 입력만 주어진다
	// 1줄에 1개씩 증가하는 순서대로 소수를 출력한다
	
	// 에라토스테네스의 체 방식 사용
	
	// 1. 크기가 N+1인 배열을 선언한 후 값은 각가의 인덱스 값으로 체운ㄷ
	// 2. 1은 소수가 아니므로 삭제한다
	// 3. 2부터 N의 제곱근까지 값을 탐색한다. 값이 인덱스값이면 그대로 두고, => 소수 인정
	// 그 값의 배수를 탐색해 0으로 변경한다 => 소수가 아님을 판단
	// 4. 배열에 남아 있는 수 중 M이상 N 이하의 수를 모두 출력한다
	
	// N의 제곱근까지만 탐색하는 이유?
	// N이 a*b라고 가정했을 때, a,b모두 N의 제곱근보다 클 수 없다
	// 따라서 N의 제곱근까지만 확인해도 전체 범위의 소수를 판별할 수 있다
	
	//슈도코드
//	M(시작 수) N(종료 수)
//	A(소수 배열)
//	for(N만큼 반복하기) {
//		A 배열 초기화하기 //  각각의 인덱스 값으로 초기화하기
//	}
//	for(N의 제제곱근까지 반복하기) {
//		소수가 아니면 넘어감
//		for(소수의 배수 값을 N까지 반복하기) {
//			이 수가 소수가 아니라는 것을 표시하기
//		}
//	}
//	for(M~N까지 반복하기) {
//		A 배열에서 소수인 값 출력하기
//	}
	
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int M = sc.nextInt();
		int N = sc.nextInt();
		int []A =  new int[N+1];
		// 1부터 시작하든, 2부터 시작하든 상관없다
	for(int i = 1; i<=N; i++) {
		A[i] = i;
	}
	// 에라토스 테네스의 체
	for(int i=2; i<= Math.sqrt(N); i++	) {
		if(A[i]==0) continue; // 소수가 아니면 넘어간다. 0으로 체크
		// i+i => 배수, N까지, i의 배수만큼 움직여야해서 j+i만큼
		for(int j=i+i; j<=N; j=j+i) {
			A[j] = 0; // 0으로 세팅
		}
	}
	// M과 N사이 출력	
	for(int i=M; i<=N; i++) {
		if(A[i]!=0) { // 0이 아니다 => 소수 일때만 
		System.out.println(A[i]);
		}
	}
	}	

}
